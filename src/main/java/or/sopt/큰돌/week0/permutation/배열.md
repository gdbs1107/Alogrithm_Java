# 배열

배열 객체는 Heap Memory에 관리되는 참조변수에 해당합니다.
그래서 배열을 참조변수를 선언할 때에는

```
타입[] 변수명;
```
으로 선언하게 되는 것이죠.

그럼 여기서 배열을 생성하려면 어떻게 할 수 있을까요?

```
변수명 = new 타입[크기];

int[] intarr = new int[2];

```

로 선언 할 수 있어요.



# List

배열과 리스트는 다르다는 것부터 인지하지 못하고 있었다는게 가히 레전드입니다.
리스트는 크기가 동적으로 변화할 수 있어, 데이터의 삽입 및 삭제가 자유롭습니다.
그 종류로는 ArrayList 와 LinkedList가 있지요.

이걸 선언하는 방법이 바로

```
List<타입> 리스트명 = new ArrayList<>;
```

로 선언 할 수 있는 것이죠. 아주 익숙하게. 이것 떄문에 배열과 리스트를 제대로 인지하지 못했다니.
그래서 리스트는 초기에 해당 리스트의 크기를 초기화해줄 필요가 없습니다.



# 배열과 리스트의 차이

1. 배열은 인덱스를 기반으로 요소를 탐색합니다 -> O(1)의 시간 복잡도를 지니게 되죠. 하지만 링크드리스트의 경우에는 노드 탐색 비용이 추가되어 O(n) 의 시간 복잡도를ㄹ ㅣㅈ니게 됩니다.
2. 배열은 인덱스 기반으로 탐색하기 때문에 수정 연산에 불리합니다. 나머지 요소를 움직여야 하기 때문이죠. 하지만 링크드는 빠릅니다. 노드 연산이니까요.
3. 메모리 효율의 관점에서도 배열과 리스트는 차이가 있습니다. 이게 좀 중요한데요.

## 배열과 리스트의 메모리 사용량 차이

배열은 정확히 해당 타입에 따른 메모리만 사용합니다.
int[] intarr = new int[4];
라면 int는 4Byte를 지니기 때문에 총 메모리 사용량이 16이지요.

같은 상황에 ArrayList라면 일단 ArrayList 객체 자체의 메모리값 + 내부 Object를 상속한 배열의 크기 + 실제 데이터의 크기(16Byte) 가 되기 때문에
메모리의 효율에 있어서는 불리합니다.

LinkedList는 말할 것도 없지요. 각 요소가 Node 객체로 관리되니까 메모리로서는 최악입니다.

하지만 각자의 장단점이 분명하기 때문에 배열의 크기가 고정되어있는 로직을 구현할때는 배열을 사용하는게 압도적으로 좋을 듯 합니다.